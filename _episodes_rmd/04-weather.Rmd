---
title: "Loading the weather data"
teaching: 30
exercises: 0
questions:
- "Example ?"
objectives:
- "Example objective"
keypoints:
- "Example keypoint"
---

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("04-weather-R-")

```

```{r, echo=FALSE, message=FALSE}
library(tidyverse)
library(lubridate)
load("checkpoints/03end.RData")
```
In the previous episodes we showed how to create functions, and test that they are working.  In this episode we will use these ideas, and expand on them to load the weather data that you downloaded at the start of the course.  

The `data` directory contains a series of files, which contain hourly weather observations from an observatory.  Let's work through the process of how to load all these files into a single (large) data-set.  There is a file, `met_README` that explains the file naming convention and the format of the data in the files. Take a look at the README file, and at one of the files containing the weather data.

The README file explains that the "Fields in each line are delimited by whitespace." This is the same as the CO2 data,
which suggests we can use `read_table()` to load a file.  The missing data value in the CO2 data was all `-999.99`. The README file states that the missing data for some fields are different from this (for example, the missing value for wind direction is `-999`).

> ## Challenge: What do we need to do?
>
> With the person sat next to you, discuss the process we will need to go through to load and clean all of the 
> files, and output a single tibble containing all their contents.  Don't worry if you don't know how to 
> do all of these tasks in R; the important thing is to thinkg about how we might break the process down into
> smaller chunks.  We can then write a function for each of these chunks, to produce our finished loading process. 
> You may realise that we already have functions that (almost) do what we need for some of these tasks.
> 
> > ## Solution
> > 
> > * We will need to process each file in turn.  We know how to loop over a vector of values, using a `for` loop.  We don't *yet* know how to list a series of files that match a pattern
> > 
> > In each file:
> >
> > * We will need to load the data into a tibble.  `readr` comes with lots of functions to do this; we can
> > use `read_table()` as we did with the CO2 data (although the parameters we use will need to be modified as the 
> > variables contained in the data are different).
> > * We will need to clean the data.  We have a function that will do this for a single field, with an arbitrary special value to represent "missing".  Our function to handle more than one field doesn't let us specify anything other than the default missing value from our CO2 data.  But we may be able to extend this function.  
> > * We will need to handle the date and time fields in the data.  We used `lubridate`'s `ymd()` function to 
> > do this with the CO2 data. So we're part way there on this
> > * It would be a good idea to validate the data.  For example, precipitation should be `>=0`, the wind direction 
> > should be between 0 and 359 degrees.
> >
> {: .solution}
{: .challenge}

## Getting started

Let's load one of the weather files into R, using the `read_table()` function, as we already know how to do this.
We'll use the following command, so that we are all using the same variable names (you should copy and paste
this command to save typing):

FIXME? Get participants to generate col_types and check sensible guesses?

```{r}
weather <- read_table("data/met_mlo_insitu_1_obop_hour_1977.txt",
                      col_names = c("obs",
                                    "yyyy",
                                    "mm",
                                    "dd",
                                    "hh",
                                    "winddir",
                                    "windspeed",
                                    "windsteadiness",
                                    "pressure",
                                    "temperature2m",
                                    "temperature10m",
                                    "temperaturetop",
                                    "relhumidity",
                                    "precipitation" ),
                      col_types = cols(
                        obs = col_character(),
                        yyyy = col_integer(),
                        mm = col_character(),
                        dd = col_character(),
                        hh = col_character(),
                        winddir = col_integer(),
                        windspeed = col_double(),
                        windsteadiness = col_integer(),
                        pressure = col_double(),
                        temperature2m = col_double(),
                        temperature10m = col_double(),
                        temperaturetop = col_double(),
                        relhumidity = col_integer(),
                        precipitation = col_integer()
                      )
)

```

> ## Challenge
>
> Create a new field, `recdate` that contains the date and hour of the observation, stored
> as a `datetime` (this is a special type of data that will let us handle the date and time
> in a similar way to the dates we used with the CO2 data).  
> 
> Hint: Look at the help file for `lubridate`'s `ymd_h()` function
> 
> > ## Solution
> > ```{r}
> > weather <- weather %>% mutate(recdate = lubridate::ymd_h(paste(yyyy,mm,dd,hh)))
> > ```
> {: .solution}
{: .challenge}


## An improved field cleaning function

In contrast to the CO2 data, the value used to represent missing data depends on the 
field.   Let's modify our `cleanfields()` function so that we can (optionally) specify
the missing value we want to use for each field.

We will need to provide a
way of giving the function a list of variable names *and* the value that we
should treat as missing.

One way of doing this is to provide a named vector of missing values.  We
can assign names to elements of a vector in R:

```{r}
missingvalues <- c(winddir = -999, windspeed = -999.9, temperature10m = -999.9)
missingvalues

```
We can extract the names of the vector using the `names()` function:
```{r}
names(missingvalues)
```


> ## More on `names()`
> 
> In addition to getting the names of an object, we can also use the `names()` function to set the names of an object:
> 
> ```{r}
> myvec <- c(1,2,3)
> names(myvec) <- c("a","b","c")
> myvec
> ```
{: .callout}


Let's modify our function so that it calls `cleanfield()` with its default `missingvalue` argument if our vector of fields
to clean doesn't have names, and calls `cleanfield()` with the appropriate missing value if we have specified names.

As we have already written tests to check that `cleanfields()` works properly, we can modify our function knowing that
if we break anything, this should be revealed in the tests we have written.  

In pseudo-code, this is what we want to do:


```{r, eval = FALSE}

cleanfields <- function(dataset, fieldlist){
  
  if( fieldstoclean doesn't have names ){
    run existing code
  } else {
    clean the fields according to the values passed and their names
  }

  return our results
}

```

There are two things we will need to figure out:

1. How to test whether `fieldstoclean` has names
2. How to write the code that will be executed if `fieldstoclean` has names


We used the `names()` function to extract the names of a named vector.  Let's look at how we can use
this to generate a condition that evaluates to `TRUE` or `FALSE` depending on whether a vector has names:

```{r}
withnames <- c(name1 = 1, name2 = 2.2)
nonames <- c("name1", "name2")

names(withnames) # Will give us the names if there are any

names(nonames) # Or NULL if there are not
```

This gets us most of the way there; but there is a problem.  Usually we can test if values are equal to each other using
`==` ( or `all.equal()` if we're dealing with floating point numbers).  This doesn't work for "special" values, like `NULL`, `NA`
and `Inf`:
```{r}

x <- NULL
# But NULL isn't TRUE (or FALSE)
x == NULL
# We need to use:
is.null(NULL)
```

> ## Indenting your code
> 
> As our code becomes more complex, keeping it tidy becomes increasingly important.  One way of doing this is
> by indenting your code, so that everything at the same "level", e.g. everything that will be executed `if` a condition is
> true, has the same indent. RStudio performs this indentation for you automatically.  You may find it gets out of sync
> as you edit and move your blocks of code around.  To re-indent your code, select it and press <kbd>Ctrl</kbd>+<kbd>I</kbd>.
> 
> RStudio will highlight the other half of quotes, brackets, and braces which can be very helpful if you forget to close a string, function or block of code.
> 
{: .callout}

> ## Challenge:  Testing whether we have names
> 
> Modify your `cleanfields()` function to test whether `fieldlist` has  names.  If it does not
> you should use your existing code to clean the fields.  If it does have names you should
> stop the function (we will write the code to clean the data when we have names and values in the 
> next challenge)
> 
> When you have written your function, you should test it still works using the tests we wrote earlier.
> 
> 
> > ## Solution
> > ```{r}
> > 
> > 
> > function(dataset, fieldlist) {
> >   if (is.null(names(fieldlist))) {
> >     if (!all(fieldlist %in% names(dataset))) {
> >       stop("Attempting to clean variables that do not exist in the dataset")
> >     }
> >     
> >     if (anyDuplicated(fieldlist) != 0) {
> >       warning("Duplicated variable names specified")
> >     }
> >     
> >     
> >     for (f in fieldlist) {
> >       dataset[[f]] <- cleanfield(dataset[[f]])
> >     }
> >     
> >   } else {
> >     stop("Not yet implemented")
> >   }
> >   
> >   return(dataset)
> >   
> > }
> > 
> > ```
> {: .solution}
{: .challenge}


We should now write the final part of the function.   We will need to loop over each element of the named `fieldlist`
vector 


> ## Challenge: Cleaning the weather data
> 
> Modify your function to implement the missing functionality.
> 
> > ## Hint - for loops:
> >There were two different approaches to using `for`:
> > ```{r, eval=FALSE}
> > for(field in fieldlist){
> >   print(field)
> > }
> > 
> > for(i in 1:length(fieldlist)){
> >   print(fieldlist[i])
> > }
> > ```
> >  
> > You will find it easier to use the second form, since we will need to refer to the positions of the 
> > elements in our vector of missing values.
> >
> {: .solution}
> > ## Solution
> > 
> > One way of solving this challenge is: 
> > 
> > ```{r}
> > 
> > cleanfields <- function(dataset, fieldlist){
> >   
> >   if ( is.null(names(fieldlist)) ) {
> >     
> >     if ( !all(fieldlist %in% names(dataset)) ) {
> >       stop("Attempting to clean variables that do not exist in the dataset")
> >     }
> >     
> >     if ( anyDuplicated(fieldlist) != 0 ) {
> >       warning("Duplicated variable names specified")
> >     }
> >     
> >     for (f in fieldlist) {
> >       dataset[[f]] <- cleanfield(dataset[[f]])
> >     }
> >     
> >   } else {
> >     
> >     variablenames <- names(fieldlist) 
> >     for (i in 1:length(fieldlist)) {
> >       
> >       variablename <- variablenames[i] 
> >       missingval <- fieldlist[i] 
> >       
> >       dataset[[ variablename ]] <- cleanfield(dataset[[ variablename ]], missingvalue = missingval)
> >       
> >     } 
> >   }
> >   
> >   return(dataset) 
> >   
> > }
> > 
> > ```
> > 
> > We could write this more succinctly, for example using `dataset[[ variablenames[i] ]]` instead of defining the 
> > `variablename` variable on each iteration of the `for` loop.  This is, however, less clear.
> >
> > One thing you may notice is that we don't now test whether the variables exist if we're using 
> > our new approach to cleaning the data.  This is not ideal; if there was more time we would 
> > write a test for this, and then modify the code implement the required functionality.
> >
> > As the function is written, this would mean we would be testing for variable names in two places, 
> > which isn't ideal - there would then be places for our code to go wrong.  A better approach might be 
> > to test whether our input variable has names.  If it does not, we could generate a named vector with the 
> > default missing value.  
> >
> > Because we've written tests for our function, we can modify it confidently, knowing that if we break anything
> > the tests will tell us.
> > 
> {: .solution }
{: .challenge }

## Introduce debugging?

## Processing a file

We now have all the elements we need to load and process a file.  We can:

* Load a file using `read_table()`
* Make the datetime field, using `ymd_h()`
* Clean the data using `cleandataset()`

Let's combine these functions into a single function.  This will take a single argument; the name of the file
it is to read.  

```{r}
loadWeatherData <- function(infile){
  # Load in a weather data file
  
  weather <- read_table(infile,
                        col_names = c("obs",
                                      "yyyy",
                                      "mm",
                                      "dd",
                                      "hh",
                                      "winddir",
                                      "windspeed",
                                      "windsteadiness",
                                      "pressure",
                                      "temperature2m",
                                      "temperature10m",
                                      "temperaturetop",
                                      "relhumidity",
                                      "precipitation" ),
                        col_types = cols(
                          obs = col_character(),
                          yyyy = col_integer(),
                          mm = col_character(),
                          dd = col_character(),
                          hh = col_character(),
                          winddir = col_integer(),
                          windspeed = col_double(),
                          windsteadiness = col_integer(),
                          pressure = col_double(),
                          temperature2m = col_double(),
                          temperature10m = col_double(),
                          temperaturetop = col_double(),
                          relhumidity = col_integer(),
                          precipitation = col_integer()
                        )
  )
  
  
  weather <- weather %>% mutate(recdate = lubridate::ymd_h(paste(yyyy,mm,dd,hh)))
  
  missingvalues <- c(winddir = -999,
                     windspeed = -999.9,
                     windsteadiness = -9,
                     pressure = -999.9,
                     temperature2m = -999.9,
                     temperature10m = -999.9,
                     temperaturetop = -999.9,
                     relhumidity = -99,
                     precipitation = -99)
  weather <- cleanfields(weather, missingvalues)
  
  return(weather)
}

cleanweather <- loadWeatherData("data/met_mlo_insitu_1_obop_hour_2010.txt")
```


## Loading more than one file at once

We have many years of weather data, and we would like to load them into a single tibble.  We can modify our `loadWeatherData()` function to do this.  We already know how to iterate over a vector using a `for` loop.  Let's make an example vector by hand, while we develop the function:

```{r}
weatherfiles <- c("data/met_mlo_insitu_1_obop_hour_1977.txt", "data/met_mlo_insitu_1_obop_hour_1978.txt")
```

What happens if we try to use this with our existing function?

FIXME - enable before release.  Disabled so whole episode can be run in Rstudio

```{r, eval=FALSE}
cleanweather <- loadWeatherData(weatherfiles)
```

FIXME - introduce debugger here?

We need to modify our fuction to loop over each element of the vector, and load the corresponding file:


```{r}
loadWeatherData <- function(infiles){
  # Load in a weather data file
  
  for (infile in infiles) {  
    weather <- read_table(infile,
                          col_names = c("obs",
                                        "yyyy",
                                        "mm",
                                        "dd",
                                        "hh",
                                        "winddir",
                                        "windspeed",
                                        "windsteadiness",
                                        "pressure",
                                        "temperature2m",
                                        "temperature10m",
                                        "temperaturetop",
                                        "relhumidity",
                                        "precipitation" ),
                          col_types = cols(
                            obs = col_character(),
                            yyyy = col_integer(),
                            mm = col_character(),
                            dd = col_character(),
                            hh = col_character(),
                            winddir = col_integer(),
                            windspeed = col_double(),
                            windsteadiness = col_integer(),
                            pressure = col_double(),
                            temperature2m = col_double(),
                            temperature10m = col_double(),
                            temperaturetop = col_double(),
                            relhumidity = col_integer(),
                            precipitation = col_integer()
                          )
    )
    
    
    weather <- weather %>% mutate(recdate = lubridate::ymd_h(paste(yyyy,mm,dd,hh)))
    
    missingvalues <- c(winddir = -999,
                       windspeed = -999.9,
                       windsteadiness = -9,
                       pressure = -999.9,
                       temperature2m = -999.9,
                       temperature10m = -999.9,
                       temperaturetop = -999.9,
                       relhumidity = -99,
                       precipitation = -99)
    weather <- cleanfields(weather, missingvalues)
  }
  return(weather)
}
```


```{r}
cleanweather <- loadWeatherData(weatherfiles)
```

That looks like it's worked; but what does our `cleanweather` data set contain?

```{r}
cleanweather %>%  
  group_by(yyyy) %>% 
  count()  
```

We only have data for the most recent year that we read in.  This is because the `weather` data-set gets overwritten each time we run through the `for` loop.  Let's modify the function so that we append the current year's data to a tibble that we define out of the loop.

```{r}
loadWeatherData <- function(infiles){
  # Load in a weather data file
  allweather <- NULL
  for (infile in infiles) {  
    weather <- read_table(infile,
                          col_names = c("obs",
                                        "yyyy",
                                        "mm",
                                        "dd",
                                        "hh",
                                        "winddir",
                                        "windspeed",
                                        "windsteadiness",
                                        "pressure",
                                        "temperature2m",
                                        "temperature10m",
                                        "temperaturetop",
                                        "relhumidity",
                                        "precipitation" ),
                          col_types = cols(
                            obs = col_character(),
                            yyyy = col_integer(),
                            mm = col_character(),
                            dd = col_character(),
                            hh = col_character(),
                            winddir = col_integer(),
                            windspeed = col_double(),
                            windsteadiness = col_integer(),
                            pressure = col_double(),
                            temperature2m = col_double(),
                            temperature10m = col_double(),
                            temperaturetop = col_double(),
                            relhumidity = col_integer(),
                            precipitation = col_integer()
                          )
    )
    
    
    weather <- weather %>% mutate(recdate = lubridate::ymd_h(paste(yyyy,mm,dd,hh)))
    
    missingvalues <- c(winddir = -999,
                       windspeed = -999.9,
                       windspeed = -99.9, ## Some records use this as missing
                       windsteadiness = -9,
                       pressure = -999.9,
                       temperature2m = -999.9,
                       temperature10m = -999.9,
                       temperaturetop = -999.9,
                       relhumidity = -99,
                       precipitation = -99)
    weather <- cleanfields(weather, missingvalues)
    
    
    
    allweather <- bind_rows(allweather, weather)
  }
  return(allweather)
}
```




```{r}
cleanweather <- loadWeatherData(weatherfiles)
```


```{r}
cleanweather %>%  
  group_by(yyyy) %>% 
  count()  
```

So we can now pass more than one file to our `loadWeatherData` function.   Rather than type all the files in, we
can use the `list.files()` function to generate the vector of filenames:

```{r}
weatherfiles <- list.files(path="./data", "met_mlo_ins*",full.names=TRUE)
cleanweather <- loadWeatherData(weatherfiles)
cleanweather %>%  
  group_by(yyyy) %>% 
  count()  %>% print(n=Inf)
```

Are we missing data?

```{r}
cleanweather %>%  
  group_by(yyyy, mm, dd) %>% 
  count()  %>% print(n=Inf) %>% 
  filter(n != 24)
```

```{r}
ggplot(data = cleanweather, aes(x=recdate, y=temperature2m) ) + geom_line()
```

```{r}
cleanweather %>% filter(yyyy == 2010) %>% mutate(dayinyear = yday(recdate)) %>% 
  ggplot(aes(x=hh, y=dayinyear, fill = temperature2m)) + geom_raster()

```


```{r}

cleanweather %>% filter(temperature2m > 80)
cleanweather %>% filter(windspeed < 0)
cleanweather %>% filter(pressure < 0)
cleanweather %>% filter(winddir < 0 | winddir > 360) # Recode 360s to 0s?

```

Something has gone wrong...  challenge is working out what.  Need to use read_table2() or read_table(guess_max = Inf)



```{r, echo=FALSE}
save.image(file = "checkpoints/04end.RData")
```
