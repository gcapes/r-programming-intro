---
title: "Creating Functions"
teaching: 30
exercises: 0
questions:
- "How do I make a function?"
- "How can I test my functions?"
- "How should I document my code?"
objectives:
- "Define a function that takes arguments."
- "Return a value from a function."
- "Test a function."
- "Set default values for function arguments."
- "Explain why we should divide programs into small, single-purpose functions."
keypoints:
- "Define a function using `name <- function(...args...) {...body...}`."
- "Call a function using `name(...values...)`."
- "R looks for variables in the current stack frame before looking for them at the top level."
- "Use `help(thing)` to view help for something."
- "Put comments at the beginning of functions to provide help for that function."
- "Annotate your code!"
- "Specify default values for arguments when defining a function using `name = value` in the argument list."
- "Arguments can be passed by matching based on name, by position, or by omitting them (in which case the default value is used)."
---

(This episode is derived from episode 2 of [Software Carpentry's Programming with R course](https://github.com/swcarpentry/r-novice-inflammation/))

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("02-func-R-")
```

```{r, echo=FALSE, message=FALSE}
library(tidyverse)
library(lubridate)
load("checkpoints/01end.RData")
```


In the previous episode we loaded in the CO2 data and recoded the missing values to `NA`.    In this
episode we will recode the missing values using a function.

Before we write a function to recode the missing values, let's illustrate writing a simple function to convert temperatures: 

### Defining a Function

Let's start by defining a function `fahr_to_kelvin` that converts temperatures from Fahrenheit to Kelvin:

```{r}
fahr_to_kelvin <- function(temp) {
  kelvin <- ((temp - 32) * (5 / 9)) + 273.15
  return(kelvin)
}
```

We define `fahr_to_kelvin` by assigning it to the output of `function`.
The list of argument names are contained within parentheses.
Next, the [body]({{ page.root }}/reference/#function-body) of the function--the statements that are executed when it runs--is contained within curly braces (`{}`).
The statements in the body are indented by two spaces, which makes the code easier to read but does not affect how the code operates.

When we call the function, the values we pass to it are assigned to those variables so that we can use them inside the function.
Inside the function, we use a [return statement]({{ page.root }}/reference/#return-statement) to send a result back to whoever asked for it.

> ## Automatic Returns
>
> In R, it is not necessary to include the return statement.
> R automatically returns whichever variable is on the last line of the body
> of the function. Since we are just learning, we will explicitly define the
> return statement.
{: .callout}

Let's try running our function.
Calling our own function is no different from calling any other function:

```{r}
# freezing point of water
fahr_to_kelvin(32)
# boiling point of water
fahr_to_kelvin(212)
```

We've successfully called the function that we defined, and we have access to the value that we returned.

### Composing Functions

Now that we've seen how to turn Fahrenheit into Kelvin, let's write another function to turn Kelvin into Celsius:

```{r}
kelvin_to_celsius <- function(temp) {
  celsius <- temp - 273.15
  return(celsius)
}

#absolute zero in Celsius
kelvin_to_celsius(0)
```

What about converting Fahrenheit to Celsius?
We could write out the formula, but we don't need to.
Instead, we can [compose]({{ page.root }}/reference/#function-composition) the two functions we have already created:

```{r}
fahr_to_celsius <- function(temp) {
  temp_k <- fahr_to_kelvin(temp)
  result <- kelvin_to_celsius(temp_k)
  return(result)
}

# freezing point of water in Celsius
fahr_to_celsius(32.0)
```

This is our first taste of how larger programs are built: we define basic
operations, then combine them in ever-larger chunks to get the effect we want.
Real-life functions will usually be larger than the ones shown here--typically half a dozen to a few dozen lines--but they shouldn't ever be much longer than that, or the next person who reads it won't be able to understand what's going on.

> ## Chaining Functions
>
> This example showed the output of `fahr_to_kelvin` assigned to `temp_k`, which
> is then passed to `kelvin_to_celsius` to get the final result. It is also possible
> to perform this calculation in one line of code, by "chaining" functions
> together, like so:
>
> ```{r chained-example}
> # freezing point of water in Celsius
> kelvin_to_celsius(fahr_to_kelvin(32.0))
> ```
{: .callout}

> ## Create a Function
>
> The `c` function lets us concatenate elements of a vector.
> e.g. `x <- c("A", "B", "C")` creates a vector `x` with three elements.
> Furthermore, we can extend that vector again using `c`, e.g. `y <- c(x, "D")` creates a vector `y` with four elements.
> Write a function called `fence` that takes two vectors as arguments, called
> `original` and `wrapper`, and returns a new vector that has the wrapper vector
> at the beginning and end of the original:
>
> ```{r, echo=-1}
> fence <- function(original, wrapper) {
>    answer <- c(wrapper, original, wrapper)
>    return(answer)
> }
> best_practice <- c("Write", "programs", "for", "people", "not", "computers")
> asterisk <- "***"  # R interprets a variable with a single value as a vector
>                    # with one element.
> fence(best_practice, asterisk)
> ```
>
> > ## Solution
> > ~~~
> > fence <- function(original, wrapper) {
> >   answer <- c(wrapper, original, wrapper)
> >   return(answer)
> > }
> > ~~~
> > {: .r}
> {: .solution}
>
> If the variable `v` refers to a vector, then `v[1]` is the vector's first element and `v[length(v)]` is its last (the function `length` returns the number of elements in a vector).
> Write a function called `outside` that returns a vector made up of just the first and last elements of its input:
>
> ```{r, echo=-1}
> outside <- function(v) {
>   first <- v[1]
>    last <- v[length(v)]
>    answer <- c(first, last)
>    return(answer)
> }
> dry_principle <- c("Don't", "repeat", "yourself", "or", "others")
> outside(dry_principle)
> ```
{: .challenge}

> ## The Call Stack
>
> For a deeper understanding of how functions work,
> you'll need to learn how they create their own environments and call other functions.
> Function calls are managed via the call stack.
> For more details on the call stack,
> have a look at the [supplementary material]({{ page.root }}/14-supp-call-stack/).
{: .callout}

> ## Named Variables and the Scope of Variables
>
>  + Functions can accept arguments explicitly assigned to a variable name in
>    in the function call `functionName(variable = value)`, as well as arguments by
>    order:
> ```{r}
> input_1 = 20
> mySum <- function(input_1, input_2 = 10) {
>   output <- input_1 + input_2
>   return(output)
> }
> ```
>
> 1.  Given the above code was run, which value does `mySum(input_1 = 1, 3)` produce?
>     1. 4
>     2. 11
>     3. 23
>     4. 30
> 2.  If `mySum(3)` returns 13, why does `mySum(input_2 = 3)` return an error?
{: .challenge}

## Handling missing values

Now we've seen how to write a function, and to pass parameters to it, let's write a function that will recode the values in our CO2 data that are invalid to `NA`.  R uses the special `NA` to represent data that are not available.

It's often useful to work with a smaller version of your data when developing a code, particularly if your program takes some time to run.  Let's just work with the first 5 rows of our CO2 data:

```{r}
co2small <- co2weekly[1:5,]
```

Let's think about the tasks we need to perform, and how we might write functions to do them (or use existing functions to do them).

1. We will need to specify and select a column of data from the tibble.
2. We will need to convert each value in this data to `NA` if it equals `-999.99`, and leave it unchanged otherwise.
3. We will need to replace the data in the tibble with the new data.

There are already functions in R to perform tasks 1 and 3.  We can select a column of data from a tibble in several ways:

```{r}
co2small[,"co2Ppm"] # Which will return a tibble
co2small$co2Ppm # which will return a vector
co2small[["co2Ppm"]] # which will also return a vector
```

You might recall that R is vectorised.  This makes it easy to perform the same operation on all elements of a vector.  For this reason, the second and third approaches are likely to be more useful when writing functions.   Third approach has the advantage that the column of data we want is named in a string.  So we could put our string in a variable, and then write:

```{r, eval=FALSE}
wantedcolumn <- "co2Ppm"
co2small[[wantedcolumn]]
```

Similarly, we can add or replace a new column of data using the assignment operator, `<-`:

```{r}
co2small[["newcolumn"]] <- c(10,20,30,40,50)

co2small[["co2Ppm"]] <- c(0,0,0,0,0)

co2small %>% select(sampledate, co2Ppm, newcolumn)
```

Before we go any further, let's  regenerate `co2small`, as we've overwritten some of the data:

```{r}
co2small <- co2weekly[1:5,]
```

This just leaves task 2 to worry about.   We need to go through each element of a vector and change its value to `NA` `if` it is equal to `-999.99`.  We could do this using a loop to iterate over each element of the vector (we will discuss loops shortly), but this tends to be slow in R.  Instead, we can use the function `ifelse` to perform this transformation:

```{r}
demodata <- 1:10
ifelse(demodata == 5, demodata, NA)
```

Let's unpick this to understand what the `ifelse()` function is doing;

```{r}
demodata <- 1:10
demodata == 5
```

The first argument of `ifelse()` evaluates to a logical vector. If the ith element of the vector is `TRUE`, `ifelse()` will output the ith element of the 2nd argument (so the ith element of `demodata` in this example).  If the element is FALSE the ith element of the 3rd argument will be replaced.  But the 3rd argument is only a single value...what's going on here?  You may remember that R `recycles` vectors if they are too short. This is what happens here; as the 3rd argument in our example consists of a single value, it will be output for all elements that are  `FALSE`

> ## Challenge: putting this all together
> 
> Write a function, `cleanfield()` that will take a vector of data and replace
> all instances of "-999.99" with NA, and then return a vector with the cleaned data.
> Your function should use -999.99 as the default value representing missing data, but
> allow the user to override this
>
> > ## Solution
> > ```{r}
> > cleanfield <- function(indata, missingvalue = -999.99){
> >  outdata <- ifelse(indata == missingvalue, NA, indata)
> >  return(outdata)
> > }
> > ```
> > 
> {: .solution}
{: .challenge}

```{r, echo = FALSE}

cleanfield <- function(indata, missingvalue = -999.99){
 outdata <- ifelse(indata == missingvalue, NA, indata)
 return(outdata)
}
```

We can use the `cleanfield()` function to clean each of our variables in turn.  For example:
```{r}
co2small[["co2Ppm"]] <- cleanfield(co2small[["co2Ppm"]])
co2small[["co2OneYearAgo"]] <- cleanfield(co2small[["co2OneYearAgo"]])
# etc..
co2small

```
The function works, but there is a lot of repetition in our code.  This makes it easy to make mistakes. Compare:
```
co2small[["co2Ppm"]] <- cleanfield(co2small[["co2Ppm"]])
```
and 
```
co2small[["co2PPm"]] <- cleanfield(co2small[["co2Ppm"]])
```

The second line of code will produce a *new* column, `co2PPm`, rather than replacing the existing data.

Let's write another function that will take a tibble, and a vector of variables we wish to apply
the `cleanfield()` function to.

## For loops

In this case we will need to loop over the vector of variable names.   The `for` loop is the programming construct we can use to do this:

```{r}
testdata <- 10:15
for (v in testdata) {
  print(paste("The variable v has value:",v))
}
```

The for loop will iterate over each element of the vector `testdata`, putting the value of that element into the
variable `v`.  In the example above we've printed out its value.  

Often we want to alter the values of elements in the array as we loop over them.  To do this we need to adopt 
a slightly different approach:

```{r}
for (i in 1:length(testdata)) {
  print(paste("Element number", i, "of the vector is", testdata[i]))
  
}

```

> ## Making your code robust
>
> In the example above we could have written `for (i in 1:6)`, since this is the length
> of the testdata vector.    By using `length(testdata)` our code will be able to handle
> any length of the `testdata` vector.  This makes the code more generalisable and robust
{: .callout}

By setting up the loop this way we can assign new values to the elements of `testtdata`.  For example, to multiply each element by 2, we could use:

```{r}
for (i in 1:length(testdata)) {
  
  testdata[i] <- testdata[i] * 2
  
}
print(testdata)
```

(In practice we'd never do this; since R is vectorised, we could run `testdata <- testdata * 2`.  This is much quicker to run than creating a `for` loop, and is much less to type)

## Processing multiple columns
As a recap, we could clean a single column of our data using:

```{r}
co2small[["co2Ppm"]] <- cleanfield(co2small[["co2Ppm"]])
```

We can use a `for` loop to run our field cleaning function `cleanfield()` on more than one column at once

> ## Challenge: Cleaning multiple fields
> 
> Write a function, `cleanfields()` that will call the `cleanfield()` function (with its default `missingvalue`
> parameter) on each of the variables whose names are given in a character vector.
> 
> For example,
> 
> ```{r, eval = FALSE}
> fieldsWithMissingData <- c("co2Ppm", "co2OneYearAgo", "co2TenYearsAgo", "co2Increase1800")
> cleanfields(co2small, fieldsWithMissingData)
> ```
> should clean our data-file
> 
> > ## Solution
> >
> >```{r}
> ># Clean multiple fields of data
> >cleanfields <- function(dataset, fieldlist){
> >  
> >  for (f in fieldlist) {
> >    dataset[[f]] <- cleanfield(dataset[[f]])
> >  }
> > 
> >  return(dataset) 
> >}
> >
> >```
> >
> {: .solution}
{: .challenge}

```{r, echo = FALSE}
# Clean multiple fields of data
cleanfields <- function(dataset, fieldlist){
  
  for (f in fieldlist) {
    dataset[[f]] <- cleanfield(dataset[[f]])
  }
  
  return(dataset) 
}

```



## Checking our results

Let's run our function on our main data-set, and plot the results to  verify it has done what we expected:

```{r}
fieldsWithMissingData <- c("co2Ppm", "co2OneYearAgo", "co2TenYearsAgo", "co2Increase1800")
co2weekly <- cleanfields(co2weekly, fieldsWithMissingData) 
ggplot(data = co2weekly, aes(x = sampledate, y = co2Ppm)) + geom_line() 
```

The `-999.99`s that were visible on the plot in episode 1 have now been removed.  `NA`s are shown as gaps in the 
line plotted by `geom_line()`

This suggests that our function is behaving as we expect, for this data-set.   We can (and should) adopt a more formal approach to testing the functionality of our function by writing *unit tests*.   These let us test *specific* elements of our function's functionality.    If we need to modify our function the unit tests let us confirm that our change hasn't broken any of the function's existing functionality.

The R package `testthat` makes it easy for us to write unit tests to verify our function behaves as we'd like.  If you put your functions in a package (see, for example, FIXME), it integrates well with the development process.  For now let's put our tests in a separate file.  In this file we'll load the `testthat` package, and `source()` the file containing our functions:

```{r, eval=FALSE}
library("testthat")
source("myfunctions.R")

```

```{r, echo=FALSE}
library("testthat")
```


FIXME - finish.  Perhaps include example test file in data package?






## Loading temperature data

The `data` directory contains a series of files, which contain hourly weather observations from an observatory.  Let's work through the process of how to load all these files into a single (large) data-set.  There is a file, `met_README` that explains the file naming convention and the format of the data in the files. Take a look at the README file, and at one of the files containing the weather data.

The README file explains that the "Fields in each line are delimited by whitespace." This is the same as the CO2 data,
which suggests we can use `read_table()` to load a file.  The missing data value in the CO2 data was all `-999.99`. The README file states that the missing data for some fields are different from this (for example, the missing value for wind direction is `-999`).

> ## Challenge: What do we need to do?
>
> With the person sat next to you, discuss the process we will need to go through to load and clean all of the 
> files, and output a single tibble containing all their contents.  Don't worry if you don't know how to 
> do all of these tasks in R; the important thing is to thinkg about how we might break the process down into
> smaller chunks.  We can then write a function for each of these chunks, to produce our finished loading process. 
> You may realise that we already have functions that (almost) do what we need for some of these tasks.
> 
> > ## Solution
> > 
> > * We will need to process each file in turn.  We know how to loop over a vector of values, using a `for` loop.  We don't *yet* know how to list a series of files that match a pattern
> > 
> > In each file:
> >
> > * We will need to load the data into a tibble.  `readr` comes with lots of functions to do this; we can
> > use `read_table()` as we did with the CO2 data (although the parameters we use will need to be modified as the 
> > variables contained in the data are different).
> > * We will need to clean the data.  We have a function that will do this for a single field, with an arbitrary special value to represent "missing".  Our function to handle more than one field doesn't let us specify anything other than the default missing value from our CO2 data.  But we may be able to extend this function.  
> > * We will need to handle the date and time fields in the data.  We used `lubridate`'s `ymd()` function to 
> > do this with the CO2 data. So we're part way there on this
> > * It would be a good idea to validate the data.  For example, precipitation should be `>=0`, the wind direction 
> > should be between 0 and 359 degrees.
> >
> {: .solution}
{: .challenge}

## Getting started

Let's load one of the weather files into R, using the `read_table()` function, as we already know how to do this.
We'll use the following command, so that we are all using the same variable names (you should copy and paste
this command to save typing):

FIXME? Get participants to generate col_types and check sensible guesses?

```{r}
weather <- read_table("data/met_mlo_insitu_1_obop_hour_1977.txt",
                      col_names = c("obs",
                                    "yyyy",
                                    "mm",
                                    "dd",
                                    "hh",
                                    "winddir",
                                    "windspeed",
                                    "windsteadiness",
                                    "pressure",
                                    "temperature2m",
                                    "temperature10m",
                                    "temperaturetop",
                                    "relhumidity",
                                    "precipitation" ),
                      col_types = cols(
                        obs = col_character(),
                        yyyy = col_integer(),
                        mm = col_character(),
                        dd = col_character(),
                        hh = col_character(),
                        winddir = col_integer(),
                        windspeed = col_double(),
                        windsteadiness = col_integer(),
                        pressure = col_double(),
                        temperature2m = col_double(),
                        temperature10m = col_double(),
                        temperaturetop = col_double(),
                        relhumidity = col_integer(),
                        precipitation = col_integer()
                      )
)

```

> ## Challenge
>
> Create a new field, `recdate` that contains the date and hour of the observation, stored
> as a `datetime` (this is a special type of data that will let us handle the date and time
> in a similar way to the dates we used with the CO2 data).  
> 
> Hint: Look at the help file for `lubridate`'s `ymd_h()` function
> 
> > ## Solution
> > ```{r}
> > weather <- weather %>% mutate(recdate = lubridate::ymd_h(paste(yyyy,mm,dd,hh)))
> > ```
> {: .solution}
{: .challenge}


## An improved field cleaning function

Let's deal with making our `cleanfields()` function work with 
something other than the default missing value.   We will need to provide a
way of giving the function a list of variable names *and* the value that we
should treat as missing.

One way of doing this is to provide a named vector of missing values.  We
can assign names to elements of a vector in R:

```{r}
missingvalues <- c(winddir = -999, windspeed = -999.9, temperature10m = -999.9)
missingvalues

```
We can extract the names of the vector using the `names()` function:
```{r}
names(missingvalues)
```

Note that we can also use the `names()` function to set the names of an object:

```{r}
myvec <- c(1,2,3)
names(myvec) <- c("a","b","c")
myvec
```
This approach is easier if we're nameing vectors in a function, for example.  But it makes it easier
to assign names to the wrong elements if you type the two vectors by hand.  In contrast, in the first method it
is clearer *what* the name we're assigning to each element is.

This gives us all the "ingredients" we need to write a function that we can use to clean the weather data.

FIXME - too many concepts in one go for this challenge? Perhaps split into 2 challenges?

> ## Challenge: Cleaning the weather data
> 
> Using the `cleanfields()` function we wrote earlier as a starting point, create a function, `cleanfields2()`
> that will read a named vector of missing values and use these to clean the data.  
> 
> Hint:  There were two different approaches to using `for`:
> ```{r, eval=FALSE}
> for(field in fieldlist){
>   print(field)
> }
> 
> for(i in 1:length(fieldlist)){
>   print(fieldlist[i])
> }
> ```
> 
> You will find it easier to use the second form, since we will need to refer to the positions of the 
> elements in our vector of missing values.
> 
> > ## Solution
> > 
> > One way of solving this challenge is: 
> > 
> > ```{r}
> > cleanfields2 <- function(dataset, missinglist){
> >   
> >   variablenames <- names(missinglist) 
> >   for (i in 1:length(missinglist)) {
> >     variablename = variablenames[i] 
> >     missingval = missinglist[i] 
> >     dataset[[ variablename ]] <- cleanfield(dataset[[ variablename ]], missingvalue = missingval)
> >   }
> >   
> >   return(dataset) 
> > }
> > ```
> > 
> > We could write this more succinctly, for example using `dataset[[ variablenames[i] ]]` instead of defining the 
> > `variablename` variable on each iteration of the `for` loop.  This is, however, less clear.
> > 
> {: .solution }
{: .challenge }

```{r, echo =FALSE}
cleanfields2 <- function(dataset, missinglist){
  
  variablenames <- names(missinglist) 
  for (i in 1:length(missinglist)) {
    variablename = variablenames[i] 
    missingval = missinglist[i] 
    dataset[[ variablename ]] <- cleanfield(dataset[[ variablename ]], missingvalue = missingval)
  }
  
  return(dataset) 
}
```
We now have two functions, `cleanfields()` and `cleanfields2()`, which do almost the same thing.   It would be 
good if we could combine these into a single function, which would call the appropriate version depending on 
whether we gave it a vector of variable names (for `cleanfields()`),  or a vector of named missing values (for `cleanfields2()`)

We need a way of testing whether the vector has names, and a way of doing one thing if it does, and another if it doesn't.  

## if

The `if...else` construct lets us take an action if a condition is true:

```{r}
x <- 5

x < 3
if (x < 3) {
  print("x is less than 3") # This isn't executed
}

# Using else is optional
if (x < 3) {
  print("x is less than 3") # This isn't executed
} else {
  print("x is not less than 3")
}

```

The condition we test can be anything that evaluates to a single `TRUE` or `FALSE` value.

We can use this to work out which version of our function we want to call.  Using pseudo code:

```{r, eval = FALSE}

cleandataset <- function(dataset, fieldstoclean){
  
  if( fieldstoclean doesn't have names ){
    run cleanfields
  } else {
    run cleanfields2
  }

  return our results
}

```

We used the `names()` function to extract the names of a named vector.  Let's look at how we can use
this to generate a condition that evaluates to `TRUE` or `FALSE` depending on whether a vector has names:

```{r}
withnames <- c(name1 = 1, name2 = 2.2)
nonames <- c("name1", "name2")

names(withnames) # Will give us the names if there are any

names(nonames) # Or NULL if there are not

# But NULL isn't TRUE (or FALSE)
# We need to use 
is.null(NULL)
# to see whether something is NULL
is.null(c(1,2,3))
```

> ## Challenge: Combining the functions
> 
> Modify the pseudocode above to write a function, `cleandataset(dataset, fieldstoclean)`, that will accept either a list of field names or a named numeric vector, and call the appropriate function `cleanfield()` or `cleanfield2()`
> 
> > ## Solution
> > 
> > ```{r}
> > 
> > cleandataset <- function(dataset, fieldstoclean) {
> >   
> >   if ( is.null( names(fieldstoclean)) ) {
> >     cleandata <- cleanfields(dataset, fieldstoclean)
> >   } else {
> >     cleandata <- cleanfields2(dataset, fieldstoclean)
> >   }
> >   
> >   return(cleandata)
> > }
> > 
> > cleandataset(weather, missingvalues)
> > ```
> {: .solution }
{: .challenge }

```{r, echo = FALSE}

cleandataset <- function(dataset, fieldstoclean) {
  
  if ( is.null( names(fieldstoclean)) ) {
    cleandata <- cleanfields(dataset, fieldstoclean)
  } else {
    cleandata <- cleanfields2(dataset, fieldstoclean)
  }
  
  return(cleandata)
}

```
## Processing a file

We now have all the elements we need to load and process a file.  We can:

* Load a file using `read_table()`
* Make the datetime field, using `ymd_h()`
* Clean the data using `cleandataset()`

Let's combine these functions into a single function.  This will take a single argument; the name of the file
it is to read.  

```{r}
loadWeatherData <- function(infile){
  # Load in a weather data file
  
weather <- read_table(infile,
                      col_names = c("obs",
                                    "yyyy",
                                    "mm",
                                    "dd",
                                    "hh",
                                    "winddir",
                                    "windspeed",
                                    "windsteadiness",
                                    "pressure",
                                    "temperature2m",
                                    "temperature10m",
                                    "temperaturetop",
                                    "relhumidity",
                                    "precipitation" ),
                      col_types = cols(
                        obs = col_character(),
                        yyyy = col_integer(),
                        mm = col_character(),
                        dd = col_character(),
                        hh = col_character(),
                        winddir = col_integer(),
                        windspeed = col_double(),
                        windsteadiness = col_integer(),
                        pressure = col_double(),
                        temperature2m = col_double(),
                        temperature10m = col_double(),
                        temperaturetop = col_double(),
                        relhumidity = col_integer(),
                        precipitation = col_integer()
                      )
)

  
 weather <- weather %>% mutate(recdate = lubridate::ymd_h(paste(yyyy,mm,dd,hh)))

 missingvalues <- c(winddir = -999,
                    windspeed = -999.9,
                    windsteadiness = -9,
                    pressure = -999.9,
                    temperature2m = -999.9,
                    temperature10m = -999.9,
                    temperaturetop = -999.9,
                    relhumidity = -99,
                    precipitation = -99)
 weather <- cleandataset(weather, missingvalues)

 return(weather)
}

cleanweather <- loadWeatherData("data/met_mlo_insitu_1_obop_hour_2010.txt")
```


## Loading more than one file at once

We have many years of weather data, and we would like to load them into a single tibble.  We can modify our `loadWeatherData()` function to do this.  We already know how to iterate over a vector using a `for` loop.  Let's make an example vector by hand, while we develop the function:

```{r}
weatherfiles <- c("data/met_mlo_insitu_1_obop_hour_1977.txt", "data/met_mlo_insitu_1_obop_hour_1978.txt")
```

What happens if we try to use this with our existing function?

FIXME - enable before release.  Disabled so whole episode can be run in Rstudio

```{r, eval=FALSE}
cleanweather <- loadWeatherData(weatherfiles)
```

FIXME - introduce debugger here?

We need to modify our fuction to loop over each element of the vector, and load the corresponding file:


```{r}
loadWeatherData <- function(infiles){
  # Load in a weather data file
  
  for (infile in infiles) {  
    weather <- read_table(infile,
                          col_names = c("obs",
                                        "yyyy",
                                        "mm",
                                        "dd",
                                        "hh",
                                        "winddir",
                                        "windspeed",
                                        "windsteadiness",
                                        "pressure",
                                        "temperature2m",
                                        "temperature10m",
                                        "temperaturetop",
                                        "relhumidity",
                                        "precipitation" ),
                          col_types = cols(
                            obs = col_character(),
                            yyyy = col_integer(),
                            mm = col_character(),
                            dd = col_character(),
                            hh = col_character(),
                            winddir = col_integer(),
                            windspeed = col_double(),
                            windsteadiness = col_integer(),
                            pressure = col_double(),
                            temperature2m = col_double(),
                            temperature10m = col_double(),
                            temperaturetop = col_double(),
                            relhumidity = col_integer(),
                            precipitation = col_integer()
                          )
    )
    
    
    weather <- weather %>% mutate(recdate = lubridate::ymd_h(paste(yyyy,mm,dd,hh)))
    
    missingvalues <- c(winddir = -999,
                       windspeed = -999.9,
                       windsteadiness = -9,
                       pressure = -999.9,
                       temperature2m = -999.9,
                       temperature10m = -999.9,
                       temperaturetop = -999.9,
                       relhumidity = -99,
                       precipitation = -99)
    weather <- cleandataset(weather, missingvalues)
  }
  return(weather)
}
```


```{r}
cleanweather <- loadWeatherData(weatherfiles)
```

That looks like it's worked; but what does our `cleanweather` data set contain?

```{r}
cleanweather %>%  
 group_by(yyyy) %>% 
 count()  
```

We only have data for the most recent year that we read in.  This is because the `weather` data-set gets overwritten each time we run through the `for` loop.  Let's modify the function so that we append the current year's data to a tibble that we define out of the loop.

```{r}
loadWeatherData <- function(infiles){
  # Load in a weather data file
  allweather <- NULL
  for (infile in infiles) {  
    weather <- read_table(infile,
                          col_names = c("obs",
                                        "yyyy",
                                        "mm",
                                        "dd",
                                        "hh",
                                        "winddir",
                                        "windspeed",
                                        "windsteadiness",
                                        "pressure",
                                        "temperature2m",
                                        "temperature10m",
                                        "temperaturetop",
                                        "relhumidity",
                                        "precipitation" ),
                          col_types = cols(
                            obs = col_character(),
                            yyyy = col_integer(),
                            mm = col_character(),
                            dd = col_character(),
                            hh = col_character(),
                            winddir = col_integer(),
                            windspeed = col_double(),
                            windsteadiness = col_integer(),
                            pressure = col_double(),
                            temperature2m = col_double(),
                            temperature10m = col_double(),
                            temperaturetop = col_double(),
                            relhumidity = col_integer(),
                            precipitation = col_integer()
                          )
    )
    
    
    weather <- weather %>% mutate(recdate = lubridate::ymd_h(paste(yyyy,mm,dd,hh)))
    
    missingvalues <- c(winddir = -999,
                       windspeed = -999.9,
                       windspeed = -99.9, ## Some records use this as missing
                       windsteadiness = -9,
                       pressure = -999.9,
                       temperature2m = -999.9,
                       temperature10m = -999.9,
                       temperaturetop = -999.9,
                       relhumidity = -99,
                       precipitation = -99)
    weather <- cleandataset(weather, missingvalues)
    
    
    
    allweather <- bind_rows(allweather, weather)
  }
  return(allweather)
}
```




```{r}
cleanweather <- loadWeatherData(weatherfiles)
```


```{r}
cleanweather %>%  
 group_by(yyyy) %>% 
 count()  
```

So we can now pass more than one file to our `loadWeatherData` function.   Rather than type all the files in, we
can use the `list.files()` function to generate the vector of filenames:

```{r}
weatherfiles <- list.files(path="./data", "met_mlo_ins*",full.names=TRUE)
cleanweather <- loadWeatherData(weatherfiles)
cleanweather %>%  
 group_by(yyyy) %>% 
 count()  %>% print(n=inf)
```

Are we missing data?

```{r}
cleanweather %>%  
 group_by(yyyy, mm, dd) %>% 
 count()  %>% print(n=inf) %>% 
  filter(n != 24)
```

```{r}
ggplot(data = cleanweather, aes(x=recdate, y=temperature2m) ) + geom_line()
```

```{r}
cleanweather %>% filter(yyyy == 2010) %>% mutate(dayinyear = yday(recdate)) %>% 
  ggplot(aes(x=hh, y=dayinyear, fill = temperature2m)) + geom_raster()

```


```{r}

cleanweather %>% filter(temperature2m > 80)
cleanweather %>% filter(windspeed < 0)
cleanweather %>% filter(pressure < 0)
cleanweather %>% filter(winddir < 0 | winddir > 360) # Recode 360s to 0s?

```

Something has gone wrong...  challenge is working out what.  Need to use read_table2() or read_table(guess_max = Inf)

