---
title: "Testing Functions"
teaching: 30
exercises: 0
questions:
- "Why should we test our functions?"
- "How do we test our functions?"
objectives:
- "To use testthat to run unit tests on our functions"
keypoints:
- "Use testthat to formalise your tests"
---

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("03-testing-R-")

```

```{r, echo=FALSE, message=FALSE}
library(tidyverse)
library(lubridate)
library(testthat)
options(testthat.default_reporter = "summary") # Default reporter doesn't display well in webpage 
load("checkpoints/02end.RData")
```

At the end of the previous episode we verified that our `cleanfields()` function worked on one of the variables using the `summary()` function.  This showed that all the `-999.9` values had been recoded to `NA`.

We can (and should) adopt a more formal approach to testing the functionality of our function by writing *unit tests*.   These let us test *specific* elements of our function's functionality.    If we need to modify our function the unit tests let us confirm that our change hasn't broken any of the function's existing functionality; this is really powerful - if we test our code, we *know* we can modify it without fear of 
breaking it.

For example, let's test that our `cleanfield()` function behaves as we expect:

```{r}
testvector <- c(1,2,-999.99)
cleanfield(testvector)

```

The power of testing comes when we write code to *check* that the function has behaved as expected.  We would need to write code to check that the `cleanfield()` function had
produced the vector `c(1,2,NA)`.

Writing such tests is cumbersome. We may also want to test things besides equality. For
example, if we pass invalid data into a function we would want to check we obtained an
error.   

The R package `testthat` makes it easy for us to write and run tests to verify our function behaves as we'd like.  If you put your functions in a package (see, for example, FIXME), it integrates well with the package development process. 

## Installing testthat

Testthat is not installed on the university teaching machines.  It can be installed like any
other R pacakge on CRAN, using:

```{r, eval=FALSE}
install.packages("testthat")
```

By default, this will install the package to your personal package directory.  On
the university machines, this is at `P:\R\win-library\3.4`.

{: .callout}

For now let's put our tests in a separate file.  It is good practice to keep
your tests in a separate directory, `tests`.  Make a directory in your project folder
called `tests`, and copy the example test file that was included in the data you downloaded at the start of the course. The file is shown below:

```{r, eval=FALSE}
context("Cleaning fields") # We group tests for similar functionality into contexts

# Note the position of {} 
test_that("Can clean a field", {
  
  testvector <- c(1,2,-999.99)
  
  expect_equal(c(1,2,NA), cleanfield(testvector))
  expect_equal(c(1,NA,-999.99), cleanfield(testvector, missingvalue = 2))
  
  expect_equal(NA, cleanfield(-999.99))
  expect_equal(1, cleanfield(1))
})

test_that("Can clean multiple fields",{
  
  testtibble <- tibble(a = c(1,2,3), b = c(3,4,-999.99), c = c(1,-999.99,2))
  
  cleanedtibbleSinglefield <- tibble(a = c(1,2,3), b = c(3, 4, NA), c = c(1, -999.99, 2))
  expect_equal(cleanedtibbleSinglefield, cleanfields(testtibble, "b"))
  
  cleanedtibbleMultifield <- tibble(a = c(1,2,3), b = c(3, 4, NA), c = c(1, NA, 2))
  expect_equal(cleanedtibbleMultifield, cleanfields(testtibble, c("b","c")))
})

```

We can execute the tests by loading the `testthat` package, and running `test_file()`:
```{r, eval=FALSE}
library("testthat")
```
```{r}
test_file("tests/test_cleandata.R")
```

`tests/test_fail.R` contains a test which expects the result of cleaning the field to
be `c(2,3,NA)` (not `c(1,2,NA)`). If a test fails we get an informative error message, 
which shows where in the file the failure occured (the number after the `#` is the line number of the file), and an indication of what the failure was:

```{r}
test_file("tests/test_fail.R")
```


> ## Challenge
> 
> The `test_cleandata.R` file doesn't test whether the code we wrote to check variable names exist
> works properly.  Modify the file where indicated to test this functionality.  You may find the `expect_error()` 
> function useful.
> 
> > ## Solution
> > 
> > ```{r}
> > 
> > test_that("Missing variable detection works",{
> >   
> >   # Make a test tibble to run the tests on
> >   testtibble <- tibble(a = c(1,2,3), b = c(4,5,6) )
> >   # Test that we get an error if we specify a missing variable name
> >   expect_error(cleanfields(testtibble, c("a","d")))
> >   
> > })
> > ```
> {: .solution}
{: .challenge}

> ## Challenge: Repeated variable names
> 
> At present we can pass the same variable name to our `cleanfields()` function more than once, e.g.
> ```{r, eval=FALSE}
> cleanfields(mydata, c("field1","field2","field1"))
> ```
> 
> The function will still work, but the second pass through the data for the repeated field will have no effect.
> The user probably didn't mean to repeat the field; perhaps they made a typing error and meant field3. 
> 
> Write a test to expect a warning if a variable name is repeated.  Run your tests, and check that the test failure is reported.
> 
> Then modify your function so that the test passes.   Developing code in this way is referred to as test driven development. FIXME - provide a link to good resource.  Ask Rob?
> 
> Hint:  There are a number of ways of checking whether a vector contains duplicated elements.  `unique()` returns only the unique elements of a vector.  You could compare the length of this vector to the original vector.  `anyDuplicated()` returns the index of the first duplicated element in a vector, or 0 if there are no duplicate elements.
> 
> > ## Solution
> > 
> > A suitable test would be:
> > ```{r, eval=FALSE}
> > 
> > test_that("Duplicate variables give a warning",{
> >   
> >   testtibble <- tibble(a = c(1,2,3), b = c(4,5,6) )
> >   
> >   expect_warning(cleanfields(testtibble, c("a","a")))
> >   # Do we still get a warning if the duplicates aren't adjacent?
> >   expect_warning(cleanfields(testtibble, c("a","b","a")))
> > })
> > ```
> > 
> > These tests fail unless we modify our `cleanfields()` function:
> > 
> > ```{r}
> > cleanfields <- function(dataset, fieldlist){
> >   
> >   if ( !all(fieldlist %in% names(dataset)) ) {
> >     stop("Attempting to clean variables that do not exist in the dataset")
> >   }
> >   
> >   if ( anyDuplicated(fieldlist) != 0 ) {
> >     warning("Duplicated variable names specified")
> >   }
> >   
> >   for (f in fieldlist) {
> >     dataset[[f]] <- cleanfield(dataset[[f]])
> >   }
> >   
> >   return(dataset) 
> > }
> > 
> > ```
> {: .solution}
{: .challenge}



```{r, echo=FALSE}
save.image(file = "checkpoints/03end.RData")
```
