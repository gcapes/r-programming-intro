---
title: "Loading multiple files"
teaching: 30
exercises: 0
questions:
- "Example ?"
objectives:
- "Example objective"
keypoints:
- "Example keypoint"
---

```{r, include = FALSE}
source("../bin/chunk-options.R")
knitr_fig_path("05-multi-R-")

```

```{r, echo=FALSE, message=FALSE}
library(tidyverse)
library(lubridate)
load("checkpoints/04end.RData")
```

## Loading more than one file at once

We have many years of weather data, and we would like to load them into a single tibble.  We can modify our `loadWeatherData()` function to do this.  

We already know how to iterate over a vector using a `for` loop.  Let's make an example vector by hand, while we develop the function:

```{r}
weatherfiles <- c("data/met_mlo_insitu_1_obop_hour_1977.txt", "data/met_mlo_insitu_1_obop_hour_1978.txt", "data/met_mlo_insitu_1_obop_hour_1979.txt")
```

We need to load each file in, and then combine them all into a single file, and then clean them.

One approach to this might be to load each file in, and then append it to a master data-set.   This will work, but is actually quite slow, since the R will have to take a copy of the entire master data set each time we add more data to it.

A more efficient way of performing the task is to make a list of tibbles, and then combine these in a single step after we've loaded all of the data.

## Lists

We have previously encountered vectors, which we can create using the `c()` function:

```{r}
c(1,2,4,8)
c("a", "b", "c")
```

All of the elements of a vector must be the same data type; R will make this so if we try and make a vector with different data types:

```{r}
c(1, "a", 2, 3)
```

We can think of a _list_ as a generalisation of this; each element of the list can contain pretty much any other object.  We make a list with the `list()` function:

```{r}
mylist <- list(1, "a", 2, c(1,2,3))
mylist
```
This has created a list; the first element contains the number 1, the second the letter "a", the third contains the number 3 and the 4th element contains a vector, which contains the values 1,2 and 3.

We can use the subsetting operator, `[]` on the list in the same way we would a vector. This will return another list:

```{r}
mylist[2]
mylist[2:3]

```

To refer to the contents of a list element we use the `[[]]` operator.  In contrast to the `[]` operator, this takes a single value:

```{r}
mylist[[1]]
mylist[[4]]
```
But note we cannot use, e.g.:

```{r}
mylist[[1:2]]
```
Since this would return more than one element.

There is another way of manipulating lists, which is to name its elements:

```{r}
weatherlist <- list(temperature = 2.5, windspeed = 4, winddir = "N")
```

We can still refer to the list elements by number
```{r}
weatherlist[1:2]
```
We can also refer to them by name:

```{r}
# This will return a list
weatherlist[c("windspeed", "winddir")]
# As will this
weatherlist[c("windspeed")]

## We use [[]] to access the data itself:
weatherlist[["windspeed"]]
```

We can also return the contents of a list element with the `$` operator:

```{r}
weatherlist$windspeed
```

One useful feature of the `[[]]` operator is that we can define the element we want in a variable:

```{r}
myvar <- "windspeed"
weatherlist[[myvar]]
```

We cannot do this with the `$` operator.

This is what we want our function to do:

```{r}
loadWeatherDataPseudoCode <- function(weatherfiles){
  for (f in weatherfiles) {
    print(paste("Load in data for file", f))
  }
  print("return the tibble containing all the data")
}

loadWeatherDataPseudoCode(weatherfiles)

```

## Create a new function or modify an existing one?

We could decide to create a new function which would call `loadWeatherData()` for each file,
rather than modifying our existing function.  There are pros and cons to extending the existing
function, or creating a new one.  MORE HERE - ease of debugging vs single file is just file vector 
with length 1

{: .callout}


```{r}
loadWeatherData <- function(infiles){
  # Load in a weather data file
  
  for (infile in infiles) {  
    weather <- read_table(infile,
                          col_names = c("obs",
                                        "yyyy",
                                        "mm",
                                        "dd",
                                        "hh",
                                        "winddir",
                                        "windspeed",
                                        "windsteadiness",
                                        "pressure",
                                        "temperature2m",
                                        "temperature10m",
                                        "temperaturetop",
                                        "relhumidity",
                                        "precipitation" ),
                          col_types = cols(
                            obs = col_character(),
                            yyyy = col_integer(),
                            mm = col_character(),
                            dd = col_character(),
                            hh = col_character(),
                            winddir = col_integer(),
                            windspeed = col_double(),
                            windsteadiness = col_integer(),
                            pressure = col_double(),
                            temperature2m = col_double(),
                            temperature10m = col_double(),
                            temperaturetop = col_double(),
                            relhumidity = col_integer(),
                            precipitation = col_integer()
                          )
    )
    
    
    weather <- weather %>% mutate(recdate = lubridate::ymd_h(paste(yyyy,mm,dd,hh)))
    
    missingvalues <- c(winddir = -999,
                       windspeed = -999.9,
                       windsteadiness = -9,
                       pressure = -999.9,
                       temperature2m = -999.9,
                       temperature10m = -999.9,
                       temperaturetop = -999.9,
                       relhumidity = -99,
                       precipitation = -99)
    weather <- cleanfields(weather, missingvalues)
  }
  return(weather)
}
```


```{r}
cleanweather <- loadWeatherData(weatherfiles)
```

That looks like it's worked; but what does our `cleanweather` data set contain?

```{r}
cleanweather %>%  
  group_by(yyyy) %>% 
  count()  
```

We only have data for the most recent year that we read in.  This is because the `weather` data-set gets overwritten each time we run through the `for` loop.  Let's modify the function so that we append the current year's data to a tibble that we define out of the loop.

**This is a really bad thing to do in R - should make a list and bind togeher**


```{r}
loadWeatherData <- function(infiles){
  # Load in a weather data file
  allweather <- NULL
  for (infile in infiles) {  
    weather <- read_table2(infile,
                          col_names = c("obs",
                                        "yyyy",
                                        "mm",
                                        "dd",
                                        "hh",
                                        "winddir",
                                        "windspeed",
                                        "windsteadiness",
                                        "pressure",
                                        "temperature2m",
                                        "temperature10m",
                                        "temperaturetop",
                                        "relhumidity",
                                        "precipitation" ),
                          col_types = cols(
                            obs = col_character(),
                            yyyy = col_integer(),
                            mm = col_character(),
                            dd = col_character(),
                            hh = col_character(),
                            winddir = col_integer(),
                            windspeed = col_double(),
                            windsteadiness = col_integer(),
                            pressure = col_double(),
                            temperature2m = col_double(),
                            temperature10m = col_double(),
                            temperaturetop = col_double(),
                            relhumidity = col_integer(),
                            precipitation = col_integer()
                          )
    )
    
    
    weather <- weather %>% mutate(recdate = lubridate::ymd_h(paste(yyyy,mm,dd,hh)))
    
    missingvalues <- c(winddir = -999,
                       windspeed = -99.9, 
                       windsteadiness = -9,
                       pressure = -999.9,
                       temperature2m = -999.9,
                       temperature10m = -999.9,
                       temperaturetop = -999.9,
                       relhumidity = -99,
                       precipitation = -99)
    weather <- cleanfields(weather, missingvalues)
    
    
    
    
    allweather <- bind_rows(allweather, weather)
  }
  return(allweather)
}
```




```{r}
cleanweather <- loadWeatherData(weatherfiles)
```


```{r}
cleanweather %>%  
  group_by(yyyy) %>% 
  count()  
```

So we can now pass more than one file to our `loadWeatherData` function.   Rather than type all the files in, we
can use the `list.files()` function to generate the vector of filenames:

```{r}
weatherfiles <- list.files(path="./data", "met_mlo_ins*",full.names=TRUE)
cleanweather <- loadWeatherData(weatherfiles)
```

```{r}
summary(cleanweather)
```
```{r}
cleanweather %>% 
  ggplot(aes(x=recdate, y=windspeed)) + geom_line()

```


```{r}
cleanweather %>% 
  ggplot(aes(x=recdate, y=temperature2m)) + geom_line()
```

```{r}
cleanweather %>% 
  filter(hh == "15") %>% 
  group_by(yyyy,mm) %>% 
  summarise(meantemp = mean(temperature2m, na.rm=TRUE)) %>% 
  ggplot(aes(x=mm,y=yyyy,fill=meantemp)) + geom_raster()
```


```{r, echo=FALSE}
save.image(file = "checkpoints/05end.RData")
```